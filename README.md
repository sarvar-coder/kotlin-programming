# kotlin-programming


# 50 Kotlin Problems — Mastery Track (Leveled)

## LEVEL 1 — Core Kotlin & Discipline (1–10)

If you struggle here, everything later will be pain.

1. Reverse a string **without** using built-in reverse
2. Count vowels using expressions only (no mutable vars)
3. Palindrome check (ignore case & spaces)
4. Find max & min in `IntArray` without helpers
5. Factorial (iterative vs recursive — compare stack risk)
6. Fibonacci with memoization
7. Character frequency in a string
8. Remove duplicates from list (preserve order)
9. First non-repeating character
10. Find missing number in `1..n`

**Goal:** immutability, `when`, ranges, null-safety, expression thinking.

---

## LEVEL 2 — Collections & Functional Power (11–20)

If your code looks like Java here, you’re not learning Kotlin.

11. Implement `map()` manually
12. Implement `filter()` manually
13. Implement `reduce()` manually
14. Group words by length
15. Top-K frequent elements
16. Sliding window max sum
17. Partition list into even / odd
18. Subarray with given sum
19. Generate permutations (small N)
20. Generate power set

**Goal:** higher-order functions, performance trade-offs, readability vs control.

---

## LEVEL 3 — Modeling & Architecture (21–30)

This is where “syntax learners” fall apart.

21. Bank account system using `data class`
22. API result using sealed classes
23. Custom `equals()` & `hashCode()`
24. Immutable stack
25. Immutable queue
26. Expression evaluator using sealed classes
27. Strategy pattern using lambdas
28. State machine using sealed classes
29. LRU cache
30. Rate limiter logic

**Goal:** immutability, exhaustiveness, real design decisions.

---

## LEVEL 4 — Algorithms & Data Structures (31–40)

Skipping this caps your ceiling permanently.

31. Binary tree traversals
32. Check if tree is balanced
33. Lowest common ancestor
34. Serialize / deserialize binary tree
35. DFS & BFS (graph)
36. Detect cycle in graph
37. Shortest path (BFS or Dijkstra)
38. Trie implementation
39. Word search in grid
40. Topological sort

**Goal:** recursion limits, memory, algorithmic complexity.

---

## LEVEL 5 — Concurrency & Real Systems (41–50)

This is where Kotlin stops being “nice” and becomes *serious*.

41. Launch concurrent tasks and aggregate results
42. Producer–consumer using Channels
43. Retry with exponential backoff
44. Timeout wrapper for suspend functions
45. Parallel map using coroutines
46. Cancellation propagation demo
47. Concurrent cache using `Mutex`
48. Coroutine pipeline
49. Flow vs Channel comparison demo
50. **Original project** (no tutorial, no clone)

**Goal:** correctness under concurrency, system thinking.

---

## Rules (unchanged, non-negotiable)

1. No copy-paste
2. Write tests (even minimal)
3. Refactor old solutions
4. Explain design choices
5. Measure time & memory when relevant

---

## Brutal truth

If you finish these **50 properly**, you’ll be **ahead of 90% of Kotlin developers**.

If you rush them, you’ll be ahead of nobody.

